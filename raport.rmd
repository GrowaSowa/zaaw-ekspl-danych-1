---
title: "Raport"
author: "151774"
output:
  html_document:
    toc: true
---
```{r, echo=FALSE}
format(Sys.Date(), "%B %d, %Y")
```

## Podsumowanie


## Biblioteki
```{r}
library(dplyr)
library(ggplot2)
library(ggcorrplot)
library(plotly)
library(caret)
library(shapper)
library(DALEX)
```

## Wczytywanie danych
```{r}
data <- read.csv("data.csv")
```

## Podsumowanie zbioru surowego
```{r}
nrow(data)
```
```{r}
summary(data)
```

## Przetwarzanie wartości brakujących

Zasady czyszczenia danych:

* Kolumny duplikatowe są pomijane,
* Kolumny z 50+% wartościami N/A są pomijane,
* Rekordy z 50+% wartościami N/A (po pominięciu kolumn) są pomijane,
* Reszta wartości N/A jest podmienianych medianą,
* W wypadku danych tekstowych wartości puste są podmienianie najczęściej występującą wartością,
* Spacje na początku i końcu wartości tekstowych są usuwane. 
```{r}
keep_cols <- colSums(is.na(data)) < nrow(data) / 2
keep_cols["Limits.of.Potential.Window..V."] <- FALSE
medians <- sapply(data[, sapply(data, is.numeric)], median, na.rm = TRUE)
median_cols <- intersect(colnames(data)[keep_cols], names(medians))

data <- select(data, colnames(data)[keep_cols])
keep_rows <- rowSums(is.na(data)) < sum(keep_cols) / 2
data <- filter(data, keep_rows)
for (col in median_cols) {
  data[is.na(data[, col]), col] <- medians[col]
}

str_strip <- function(x) {
  x_sub <- x
  while (substring(x_sub, 1, 1) == " ") {
    x_sub <- substring(x_sub, 2)
  }
  while (substring(x_sub, nchar(x_sub)) == " ") {
    x_sub <- substring(x_sub, 1, nchar(x_sub) - 1)
  }
  return(x_sub)
}

string_cols <- colnames(data)[!sapply(data, is.numeric)]
for (col in string_cols) {
  data[, col] <- sapply(data[, col], str_strip)
  tt <- table(data[, col])
  max_val <- names(tt[tt == max(tt)])[1]
  data[data[, col] == "", col] <- max_val
}
```

## Podsumowanie zbioru po czyszczeniu
```{r}
nrow(data)
```
```{r}
summary(data)
```

## Szczegółowa analiza wartości atrybutów
```{r}
for (col in colnames(data)) {
  if (is.numeric(data[, col])) {
    hist(data[, col], main = col,
         xlab = "Wartość", ylab = "Wystąpienia")
  } else if (!(col %in% c("Ref.", "Electrode.Configuration"))) {
    tt <- table(data[, col])
    val_cnt <- data.frame(vals = names(tt),
                          counts = as.numeric(tt))
    print(ggplot(val_cnt, aes(x = vals, y = counts)) +
      geom_bar(stat = "identity") +
      labs(x = "Wartość", y = "Wystąpienia", title = col) +
      theme(axis.text.x = element_text(angle = 30, vjust = 0.5)))
  }
}
```

## Korelacja
```{r}
elec_conf_vallist <- unique(data$Electrode.Configuration)
elec_chem_vallist <- unique(data$Electrolyte.Chemical.Formula)
cell_conf_vallist <- unique(data$Cell.Configuration..three.two.electrode.system.)

data_w_enums <- data %>%
  mutate(Electrode.Configuration = match(Electrode.Configuration, elec_conf_vallist)) %>%
  mutate(Electrolyte.Chemical.Formula = match(Electrolyte.Chemical.Formula, elec_chem_vallist)) %>%
  mutate(Cell.Configuration..three.two.electrode.system. = match(Cell.Configuration..three.two.electrode.system., cell_conf_vallist))

ggcorrplot(cor(select(data_w_enums, where(is.numeric))))
```

## Interaktywne wykresy
```{r}
p <- ggplot(data) +
  geom_linerange(aes(x = Capacitance..F.g.,
                     ymin = Lower.Limit.of.Potential.Window..V.,
                     ymax = Upper.Limit.of.Potential.Window..V.,
                     color = Cell.Configuration..three.two.electrode.system.),
                 alpha = 0.15) +
  labs(y = "Potential.Window..V.", color = "Cell Configuration",
       title = "Porównanie konfiguracji elektrod") +
  coord_flip()

ggplotly(p)
```

```{r}
n_list <- names(head(sort(table(data$Electrolyte.Chemical.Formula), decreasing = TRUE), 10))
data_filtered <- data %>%
  filter(Electrolyte.Chemical.Formula %in% n_list)
p <- ggplot(data_filtered) +
  geom_linerange(aes(x = Capacitance..F.g.,
                     ymin = Lower.Limit.of.Potential.Window..V.,
                     ymax = Upper.Limit.of.Potential.Window..V.,
                     color = Electrolyte.Chemical.Formula),
                 alpha = 0.2) +
  labs(y = "Potential.Window..V.", color = "Chemical Formula",
       title = "Porównanie najczęstszych składów chemicznych elektrolitu") +
  coord_flip()

ggplotly(p)
```

### Trendy w badaniach

## Predykcja pojemności za pomocą regresji liniowej
```{r}
# zmiana kolumn tekstowych na enumy
elec_conf_vallist <- unique(data$Electrode.Configuration)
elec_chem_vallist <- unique(data$Electrolyte.Chemical.Formula)
cell_conf_vallist <- unique(data$Cell.Configuration..three.two.electrode.system.)

ml_data <- data %>%
  mutate(Electrode.Configuration = match(Electrode.Configuration, elec_conf_vallist)) %>%
  mutate(Electrolyte.Chemical.Formula = match(Electrolyte.Chemical.Formula, elec_chem_vallist)) %>%
  mutate(Cell.Configuration..three.two.electrode.system. = match(Cell.Configuration..three.two.electrode.system., cell_conf_vallist)) %>%
  select(-Ref.)

# podział zbioru danych
set.seed(9001)
is_training <- createDataPartition(
  y = ml_data$Capacitance..F.g.,
  p = .75,
  list = FALSE
)

training_data <- ml_data[is_training, ]
testing_data <- ml_data[-is_training, ]

# uczenie
ctrl <- trainControl(
  method = "cv",
  # number = 2,
  # repeats = 10
)
set.seed(1337)
fit <- train(
  Capacitance..F.g. ~ .,
  data = training_data,
  method = "lm",
  trControl = ctrl
)

# predykcja
predictions <- predict(fit, newdata = select(testing_data, -Capacitance..F.g.))

# shap
explainer <- explain(fit,
                     data = training_data %>% select(-Capacitance..F.g.),
                     y = as.numeric(training_data$Capacitance..F.g.))
shapped <- shap(explainer,
                new_observation = testing_data[1, ] %>%
                  select(-Capacitance..F.g.))
plot(shapped)
```