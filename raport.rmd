---
title: "Raport"
author: "151774"
output:
  html_document:
    toc: true
---
```{r, echo=FALSE}
format(Sys.Date(), "%B %d, %Y")
```

### Podsumowanie


### Biblioteki
```{r}
library(dplyr)
library(ggplot2)
library(ggcorrplot)
library(caret)
library(shapper)
```

### Wczytywanie danych
```{r}
data <- read.csv("data.csv")
```

### Podsumowanie zbioru surowego
```{r}
nrow(data)
```
```{r}
summary(data)
```

### Przetwarzanie wartości brakujących

Zasady czyszczenia danych:

* Kolumny duplikatowe są pomijane,
* Kolumny z 50+% wartościami N/A są pomijane,
* Rekordy z 50+% wartościami N/A (po pominięciu kolumn) są pomijane,
* Reszta wartości N/A jest podmienianych medianą.
```{r}
keep_cols <- colSums(is.na(data)) < nrow(data) / 2
keep_cols["Limits.of.Potential.Window..V."] <- FALSE
medians <- sapply(data[, sapply(data, is.numeric)], median, na.rm = TRUE)
median_cols <- intersect(colnames(data)[keep_cols], names(medians))

data <- select(data, colnames(data)[keep_cols])
keep_rows <- rowSums(is.na(data)) < sum(keep_cols) / 2
data <- filter(data, keep_rows)
for (col in median_cols) {
  data[is.na(data[, col]), col] <- medians[col]
}
```

### Podsumowanie zbioru po czyszczeniu
```{r}
nrow(data)
```
```{r}
summary(data)
```

### Szczegółowa analiza wartości atrybutów
```{r}
for (col in colnames(data)) {
  if (is.numeric(data[, col])) {
    hist(data[, col], main = col,
         xlab = "Wartość", ylab = "Wystąpienia")
  }
}
```

### Korelacja
```{r}
ggcorrplot(cor(select(data, where(is.numeric))))
```
<!-- interaktywne wykresy -->

### Predykcja pojemności za pomocą regresji liniowej
```{r}
# zmiana kolumn tekstowych na enumy
elec_conf_vallist <- unique(data$Electrode.Configuration)
elec_chem_vallist <- unique(data$Electrolyte.Chemical.Formula)
cell_conf_vallist <- unique(data$Cell.Configuration..three.two.electrode.system.)

ml_data <- data %>%
  mutate(Electrode.Configuration = match(Electrode.Configuration, elec_conf_vallist)) %>%
  mutate(Electrolyte.Chemical.Formula = match(Electrolyte.Chemical.Formula, elec_chem_vallist)) %>%
  mutate(Cell.Configuration..three.two.electrode.system. = match(Cell.Configuration..three.two.electrode.system., cell_conf_vallist)) %>%
  select(-Ref.)

# podział zbioru danych
set.seed(9001)
is_training <- createDataPartition(
  y = ml_data$Capacitance..F.g.,
  p = .75,
  list = FALSE
)

training_data <- ml_data[is_training, ]
testing_data <- ml_data[-is_training, ]

# uczenie
ctrl <- trainControl(
  method = "cv",
#   number = 2,
  repeats = 10
)
set.seed(1337)
fit <- train(
  Capacitance..F.g. ~ .,
  data = training_data,
  method = "lm",
  trControl = ctrl
)

# predykcja
predictions <- predict(fit, newdata = testing_data)
```